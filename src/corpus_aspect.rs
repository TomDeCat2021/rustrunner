use std::collections::{HashMap, HashSet};
use std::hash::{Hash, Hasher};
use std::collections::hash_map::DefaultHasher;
use regex::Regex;
use lazy_static::lazy_static;

#[derive(Debug, Clone)]
pub struct BytecodePattern {
    pub instruction: String,
    pub operands: Vec<String>,
    pub pattern_hash: u64,
}

#[derive(Debug, Clone)]
pub struct BytecodeFunction {
    pub name: String,
    pub bytecode_length: u32,
    pub parameter_count: u32,
    pub register_count: u32,
    pub frame_size: u32,
    pub instructions: Vec<BytecodePattern>,
    pub constants: Vec<String>,
    pub function_hash: u64,
}

#[derive(Debug, Clone)]
pub struct BytecodeAnalysis {
    pub functions: Vec<BytecodeFunction>,
    pub unique_instructions: HashSet<String>,
    pub instruction_patterns: HashSet<u64>,
    pub complexity_score: f64,
    pub analysis_hash: u64,
}

#[derive(Clone)]
pub struct GlobalBytecodeCollector {
    pub discovered_patterns: HashSet<u64>,
    pub discovered_instructions: HashSet<String>,
    pub discovered_function_patterns: HashSet<u64>,
    pub pattern_frequency: HashMap<u64, u32>,
    pub total_analyses: u32,
}

impl GlobalBytecodeCollector {
    pub fn new() -> Self {
        Self {
            discovered_patterns: HashSet::new(),
            discovered_instructions: HashSet::new(),
            discovered_function_patterns: HashSet::new(),
            pattern_frequency: HashMap::new(),
            total_analyses: 0,
        }
    }

    pub fn check_novelty(&mut self, analysis: &BytecodeAnalysis) -> bool {
        let mut has_new_patterns = false;
        
        // Check for new instruction patterns
        // for &pattern in &analysis.instruction_patterns {
        //     if !self.discovered_patterns.contains(&pattern) {
        //         self.discovered_patterns.insert(pattern);
        //         println!("DEBUG: Discovered new pattern: {}", pattern);
        //         *self.pattern_frequency.entry(pattern).or_insert(0) += 1;
        //         has_new_patterns = true;
        //     }
        // }
        
        // Check for new instructions
        for instruction in &analysis.unique_instructions {
            if !self.discovered_instructions.contains(instruction) {
                self.discovered_instructions.insert(instruction.clone());
                println!("DEBUG: Discovered new instruction: {}", instruction);
                has_new_patterns = true;
            }
        }
        
        // Check for new function patterns
        // for function in &analysis.functions {
        //     if !self.discovered_function_patterns.contains(&function.function_hash) {
        //         println!("DEBUG: Discovered new function: {}", function.name);
        //         self.discovered_function_patterns.insert(function.function_hash);
        //         has_new_patterns = true;
        //     }
        // }
        
        self.total_analyses += 1;
        has_new_patterns
    }

    pub fn get_stats(&self) -> (usize, usize, usize, u32) {
        (
            self.discovered_patterns.len(),
            self.discovered_instructions.len(),
            self.discovered_function_patterns.len(),
            self.total_analyses
        )
    }
}

lazy_static! {
    static ref BYTECODE_FUNCTION_START_REGEX: Regex = Regex::new(
        r"\[generated bytecode for function:.*?\]"
    ).unwrap();
    
    static ref BYTECODE_METADATA_REGEX: Regex = Regex::new(
        r"Bytecode length: (\d+)\s*Parameter count (\d+)\s*Register count (\d+)\s*Frame size (\d+)"
    ).unwrap();
    
    static ref BYTECODE_INSTRUCTION_REGEX: Regex = Regex::new(
        r"0x[a-fA-F0-9]+ @\s*\d+ :\s*[a-fA-F0-9 ]+\s+([A-Za-z][A-Za-z0-9]*)\s*(.*?)$"
    ).unwrap();
    
    static ref CONSTANT_POOL_REGEX: Regex = Regex::new(
        r"Constant pool \(size = (\d+)\)"
    ).unwrap();
}

impl BytecodePattern {
    pub fn new(instruction: String, operands: Vec<String>) -> Self {
        let mut hasher = DefaultHasher::new();
        instruction.hash(&mut hasher);
        operands.hash(&mut hasher);
        let pattern_hash = hasher.finish();
        
        Self {
            instruction,
            operands,
            pattern_hash,
        }
    }
}

impl BytecodeFunction {
    pub fn new(
        name: String,
        bytecode_length: u32,
        parameter_count: u32,
        register_count: u32,
        frame_size: u32,
        instructions: Vec<BytecodePattern>,
        constants: Vec<String>,
    ) -> Self {
        let mut hasher = DefaultHasher::new();
        name.hash(&mut hasher);
        bytecode_length.hash(&mut hasher);
        parameter_count.hash(&mut hasher);
        register_count.hash(&mut hasher);
        frame_size.hash(&mut hasher);
        for instruction in &instructions {
            instruction.pattern_hash.hash(&mut hasher);
        }
        constants.hash(&mut hasher);
        let function_hash = hasher.finish();
        
        Self {
            name,
            bytecode_length,
            parameter_count,
            register_count,
            frame_size,
            instructions,
            constants,
            function_hash,
        }
    }
}

impl BytecodeAnalysis {
    pub fn new(functions: Vec<BytecodeFunction>) -> Self {
        let mut unique_instructions = HashSet::new();
        let mut instruction_patterns = HashSet::new();
        let mut complexity_score = 0.0;
        
        for function in &functions {
            complexity_score += function.bytecode_length as f64;
            complexity_score += function.instructions.len() as f64 * 0.5;
            
            for instruction in &function.instructions {
                unique_instructions.insert(instruction.instruction.clone());
                instruction_patterns.insert(instruction.pattern_hash);
            }
        }
        
        // Normalize complexity score
        complexity_score = complexity_score / (functions.len() as f64 + 1.0);
        
        let mut hasher = DefaultHasher::new();
        for function in &functions {
            function.function_hash.hash(&mut hasher);
        }
        unique_instructions.len().hash(&mut hasher);
        let analysis_hash = hasher.finish();
        
        Self {
            functions,
            unique_instructions,
            instruction_patterns,
            complexity_score,
            analysis_hash,
        }
    }
}

pub fn parse_bytecode_output(output: &str) -> Result<BytecodeAnalysis, String> {
    let mut instructions = Vec::new();
    let lines: Vec<&str> = output.lines().collect();
    
    // Just scan through all lines looking for bytecode instructions
    for line in lines {
        // Try to parse as instruction - look for the specific pattern: 0x{hex} @ {num} : {hex} {instruction} {operands}
        if let Some(instr_cap) = BYTECODE_INSTRUCTION_REGEX.captures(line) {
            let instruction = instr_cap[1].to_string();
            let operands_str = instr_cap[2].trim();
            let operands: Vec<String> = if operands_str.is_empty() {
                Vec::new()
            } else {
                operands_str
                    .split_whitespace()
                    .map(|s| s.to_string())
                    .collect()
            };
            
            instructions.push(BytecodePattern::new(instruction, operands));
        }
    }
    
    if instructions.is_empty() {
        return Err("No bytecode instructions found in output".to_string());
    }
    // Create a single function containing all found instructions
    let function = BytecodeFunction::new(
        "extracted_bytecode".to_string(),
        instructions.len() as u32,
        0, // parameter_count
        0, // register_count
        0, // frame_size
        instructions,
        Vec::new(), // constants
    );
    
    Ok(BytecodeAnalysis::new(vec![function]))
}

#[derive(Clone)]
pub struct BytecodeCollector {
    pub worker_id: usize,
    pub global_collector: GlobalBytecodeCollector,
}

impl BytecodeCollector {
    pub fn new(worker_id: usize) -> Self {
        Self {
            worker_id,
            global_collector: GlobalBytecodeCollector::new(),
        }
    }
    
    pub fn analyze_js_bytecode(&mut self, js_code: &str,worker_id: u32) -> Result<(BytecodeAnalysis, bool), String> {
        // Execute the JS code with the bytecode worker (worker_id 101)
        let bytecode_worker_id = (worker_id as i32) + 100;
        
        // Execute and capture output
        let result = unsafe {
            crate::execute_script(
                js_code.as_ptr() as *mut i8,
                5000, // 5 second timeout
                0,    // fresh instance
                bytecode_worker_id
            )
        };
        
        if result != 0 {
            return Err(format!("Script execution failed with result: {}", result));
        }
        
        // Fetch stdout which contains bytecode output
        let output = unsafe {
            let output_ptr = crate::reprl_fetch_stdout(bytecode_worker_id);
           
            if output_ptr.is_null() {
                return Err("Failed to fetch stdout".to_string());
            }
            std::ffi::CStr::from_ptr(output_ptr).to_string_lossy().to_string()
        };
        
        // println!("DEBUG: Output: {:?}", output);
        // Parse bytecode from output
        let analysis = parse_bytecode_output(&output)?;
        
        // Check if this analysis contains novel patterns
        let is_novel = self.global_collector.check_novelty(&analysis);
        
        Ok((analysis, is_novel))
    }
    
    pub fn get_stats(&self) -> (usize, usize, usize, u32) {
        self.global_collector.get_stats()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_bytecode_output() {
        let sample_output = r#"
[generated bytecode for function:  (0x1dba00064d89 <SharedFunctionInfo>)]
Bytecode length: 25
Parameter count 1
Register count 3
Frame size 24
         0xc6600100074 @    0 : 13 00             LdaConstant [0]
         0xc6600100076 @    2 : cf                Star1
         0xc6600100077 @    3 : 1b fe f7          Mov <closure>, r2
    0 E> 0xc660010007a @    6 : 6d 6e 01 f8 02    CallRuntime [DeclareGlobals], r1-r2
    7 S> 0xc660010007f @   11 : 8a 01 00 00       CreateClosure [1], [0], #0
         0xc6600100083 @   15 : cf                Star1
         0xc6600100084 @   16 : 25 02 00          StaGlobal [2], [0]
         0xc6600100087 @   19 : 1b f8 f9          Mov r1, r0
         0xc660010008a @   22 : 0b f9             Ldar r0
   21 S> 0xc660010008c @   24 : b5                Return
Constant pool (size = 3)
"#;
        
        let result = parse_bytecode_output(sample_output);
        if let Err(e) = &result {
            println!("Parse error: {}", e);
        }
        assert!(result.is_ok());
        
        let analysis = result.unwrap();
        assert_eq!(analysis.functions.len(), 1);
        assert_eq!(analysis.functions[0].name, "extracted_bytecode");
        assert!(!analysis.functions[0].instructions.is_empty());
        assert_eq!(analysis.functions[0].instructions.len(), 10); // Number of bytecode instructions found
        
        // Check that we parsed instructions correctly
        let instructions: Vec<&String> = analysis.functions[0].instructions
            .iter()
            .map(|p| &p.instruction)
            .collect();
        
        println!("DEBUG: Parsed instructions: {:?}", instructions);
        
        assert!(instructions.contains(&&"LdaConstant".to_string()));
        assert!(instructions.contains(&&"Star1".to_string()));
        assert!(instructions.contains(&&"Return".to_string()));
        assert!(instructions.contains(&&"CallRuntime".to_string()));
        assert!(instructions.contains(&&"CreateClosure".to_string()));
    }

    #[test]
    fn test_parse_multiple_functions_bytecode() {
        let sample_output = r#"
[generated bytecode for function: testFunction (0x1dba00064d89 <SharedFunctionInfo>)]
Bytecode length: 15
Parameter count 0
Register count 2
Frame size 16
         0xc6600100074 @    0 : 13 00             LdaConstant [0]
         0xc6600100076 @    2 : cf                Star1
         0xc6600100077 @    3 : b5                Return

[generated bytecode for function: anotherFunction (0x1dba00064d90 <SharedFunctionInfo>)]
Bytecode length: 30
Parameter count 2
Register count 4
Frame size 32
         0xc6600100080 @    0 : 13 01             LdaConstant [1]
         0xc6600100082 @    2 : cf                Star1
         0xc6600100083 @    3 : 1b fe f7          Mov <closure>, r2
         0xc6600100086 @    6 : b5                Return
"#;
        
        let result = parse_bytecode_output(sample_output);
        assert!(result.is_ok());
        
        let analysis = result.unwrap();
        // Now creates a single function with all instructions from all functions
        assert_eq!(analysis.functions.len(), 1);
        assert_eq!(analysis.functions[0].name, "extracted_bytecode");
        assert_eq!(analysis.functions[0].instructions.len(), 6); // Total instructions from both functions
        
        // Check that we have unique instructions across both functions
        assert!(!analysis.unique_instructions.is_empty());
        assert!(analysis.unique_instructions.contains("LdaConstant"));
        assert!(analysis.unique_instructions.contains("Return"));
        assert!(analysis.unique_instructions.contains("Star1"));
        assert!(analysis.unique_instructions.contains("Mov"));
    }

    #[test]
    fn test_bytecode_pattern_creation() {
        let instruction = "LdaConstant".to_string();
        let operands = vec!["[0]".to_string()];
        
        let pattern = BytecodePattern::new(instruction.clone(), operands.clone());
        
        assert_eq!(pattern.instruction, instruction);
        assert_eq!(pattern.operands, operands);
        assert!(pattern.pattern_hash != 0);
        
        // Create another pattern with same data and verify hash consistency
        let pattern2 = BytecodePattern::new(instruction, operands);
        assert_eq!(pattern.pattern_hash, pattern2.pattern_hash);
    }

    #[test]
    fn test_bytecode_function_creation() {
        let name = "testFunction".to_string();
        let instructions = vec![
            BytecodePattern::new("LdaConstant".to_string(), vec!["[0]".to_string()]),
            BytecodePattern::new("Return".to_string(), vec![]),
        ];
        let constants = vec!["hello".to_string()];
        
        let function = BytecodeFunction::new(
            name.clone(),
            15,
            0,
            2,
            16,
            instructions.clone(),
            constants.clone(),
        );
        
        assert_eq!(function.name, name);
        assert_eq!(function.bytecode_length, 15);
        assert_eq!(function.parameter_count, 0);
        assert_eq!(function.register_count, 2);
        assert_eq!(function.frame_size, 16);
        assert_eq!(function.instructions.len(), 2);
        assert_eq!(function.constants, constants);
        assert!(function.function_hash != 0);
    }

    #[test]
    fn test_global_bytecode_collector_novelty() {
        let mut collector = GlobalBytecodeCollector::new();
        
        // Create a simple bytecode analysis
        let instructions = vec![
            BytecodePattern::new("LdaConstant".to_string(), vec!["[0]".to_string()]),
            BytecodePattern::new("Return".to_string(), vec![]),
        ];
        let function = BytecodeFunction::new(
            "test".to_string(),
            10,
            0,
            1,
            8,
            instructions,
            vec![],
        );
        let analysis = BytecodeAnalysis::new(vec![function]);
        
        // First analysis should be novel
        let is_novel1 = collector.check_novelty(&analysis);
        assert!(is_novel1);
        
        // Same analysis should not be novel
        let is_novel2 = collector.check_novelty(&analysis);
        assert!(!is_novel2);
        
        // Check stats
        let (patterns, instructions, functions, total) = collector.get_stats();
        assert!(patterns > 0);
        assert!(instructions > 0);
        assert!(functions > 0);
        assert_eq!(total, 2);
    }

    #[test]
    fn test_bytecode_collector_creation() {
        let collector = BytecodeCollector::new(1);
        assert_eq!(collector.worker_id, 1);
        
        let (patterns, instructions, functions, total) = collector.get_stats();
        assert_eq!(patterns, 0);
        assert_eq!(instructions, 0);
        assert_eq!(functions, 0);
        assert_eq!(total, 0);
    }

    #[test]
    fn test_parse_empty_bytecode_output() {
        let empty_output = "";
        let result = parse_bytecode_output(empty_output);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_invalid_bytecode_output() {
        let invalid_output = "This is not bytecode output";
        let result = parse_bytecode_output(invalid_output);
        assert!(result.is_err());
    }

    #[test]
    fn test_bytecode_analysis_complexity_score() {
        // Create functions with different complexities
        let simple_function = BytecodeFunction::new(
            "simple".to_string(),
            5,
            0,
            1,
            8,
            vec![BytecodePattern::new("Return".to_string(), vec![])],
            vec![],
        );
        
        let complex_function = BytecodeFunction::new(
            "complex".to_string(),
            50,
            2,
            5,
            40,
            vec![
                BytecodePattern::new("LdaConstant".to_string(), vec!["[0]".to_string()]),
                BytecodePattern::new("Star1".to_string(), vec![]),
                BytecodePattern::new("CallRuntime".to_string(), vec!["[DeclareGlobals]".to_string()]),
                BytecodePattern::new("Return".to_string(), vec![]),
            ],
            vec![],
        );
        
        let simple_analysis = BytecodeAnalysis::new(vec![simple_function]);
        let complex_analysis = BytecodeAnalysis::new(vec![complex_function]);
        
        // Complex function should have higher complexity score
        assert!(complex_analysis.complexity_score > simple_analysis.complexity_score);
    }

    // Integration test that uses the test JavaScript file
    #[test]
    fn test_with_real_js_file() {
        // Read the test JavaScript file
        let js_content = match std::fs::read_to_string("test_bytecode.js") {
            Ok(content) => content,
            Err(_) => {
                // If file doesn't exist, use inline content
                r#"
function testFunction() {
    var x = 1;
    var y = 2;
    return x + y;
}

function anotherFunction(a, b) {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}

var result = testFunction();
var max = anotherFunction(5, 3);
console.log("Result:", result, "Max:", max);
                "#.to_string()
            }
        };
        
        // Verify the JavaScript content is not empty
        assert!(!js_content.trim().is_empty());
        assert!(js_content.contains("testFunction"));
        assert!(js_content.contains("anotherFunction"));
        
        // Note: We can't test the actual execution without the external C functions
        // but we can test that our collector would handle this type of input
        let mut collector = BytecodeCollector::new(101);
        assert_eq!(collector.worker_id, 101);
        
        let (analysis, is_novel) = collector.analyze_js_bytecode(&js_content).unwrap();
        assert!(is_novel);
        assert!(analysis.functions.len() > 0);
        assert!(analysis.unique_instructions.len() > 0);
        assert!(analysis.instruction_patterns.len() > 0);
        assert!(analysis.complexity_score > 0.0);
        assert!(analysis.analysis_hash != 0);
        // The collector should be ready to analyze this JavaScript
        // In a real scenario, this would call analyze_js_bytecode(&js_content)
        // but that requires external C functions that aren't available in tests
    }

    #[test]
    fn test_pattern_hash_uniqueness() {
        let pattern1 = BytecodePattern::new(
            "LdaConstant".to_string(), 
            vec!["[0]".to_string()]
        );
        let pattern2 = BytecodePattern::new(
            "LdaConstant".to_string(), 
            vec!["[1]".to_string()]
        );
        let pattern3 = BytecodePattern::new(
            "Star1".to_string(), 
            vec![]
        );
        
        // Different operands should produce different hashes
        assert_ne!(pattern1.pattern_hash, pattern2.pattern_hash);
        
        // Different instructions should produce different hashes
        assert_ne!(pattern1.pattern_hash, pattern3.pattern_hash);
        assert_ne!(pattern2.pattern_hash, pattern3.pattern_hash);
    }

    #[test]
    fn test_bytecode_analysis_unique_instruction_collection() {
        let instructions = vec![
            BytecodePattern::new("LdaConstant".to_string(), vec!["[0]".to_string()]),
            BytecodePattern::new("LdaConstant".to_string(), vec!["[1]".to_string()]), // Same instruction, different operand
            BytecodePattern::new("Star1".to_string(), vec![]),
            BytecodePattern::new("Return".to_string(), vec![]),
            BytecodePattern::new("Return".to_string(), vec![]), // Duplicate
        ];
        
        let function = BytecodeFunction::new(
            "test".to_string(),
            20,
            1,
            2,
            16,
            instructions,
            vec![],
        );
        
        let analysis = BytecodeAnalysis::new(vec![function]);
        
        // Should have 3 unique instructions despite duplicates
        assert_eq!(analysis.unique_instructions.len(), 3);
        assert!(analysis.unique_instructions.contains("LdaConstant"));
        assert!(analysis.unique_instructions.contains("Star1"));
        assert!(analysis.unique_instructions.contains("Return"));
        
        // Should have more instruction patterns due to different operands
        assert!(analysis.instruction_patterns.len() >= 3);
    }
} 